#include <avr/io.h>
#define F_CPU    8000000UL
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <avr/wdt.h>

#define BAUDRATE 9600
#define UART_BUFFER_SIZE 12

volatile uint8_t counter = 0;
volatile uint8_t usiReceived = 0;
volatile uint8_t usiByteReceived = 0;
volatile uint8_t uartBuffer[UART_BUFFER_SIZE] = {'\0'};
volatile uint8_t uartBufferIndex = 0;

// Old timer values
volatile uint8_t oldTCCR0A;
volatile uint8_t oldTCCR0B;
volatile uint8_t oldTCNT0;

// time counter for sleep_delay_ms function
volatile unsigned long timer1CounterMs;
volatile uint8_t timer1SquareLevel = 0;

enum Timer1Mode {
	COUNT,
	SQUARE
};
volatile enum Timer1Mode timer1Mode = COUNT;

void setupUART() {
	cli();

	// Save old timer values
	oldTCCR0B = TCCR0B;
	oldTCCR0A = TCCR0A;
	// Disable USI
	USICR = 0;

	// PCIE not INT0 because we want to get interrupt
	// even when sleeping
	// Enable interrupt on PB1 change
	PCMSK |= 1<<PCINT0;
	GIMSK |= 1<<PCIE;
	
	// INPUT_PULLUP on DB0
	DDRB &= ~(1<<DDB0);
	PORTB |= 1 << PB0;

	sei();
}
void startUARTReceive() {
	cli();
	// Save old timer counter
	oldTCNT0 = TCNT0;
	// Didn't receive anything yet
	usiReceived = 0;

	// Disable pin change interrupts
	GIMSK &= ~(1<<PCIE);
	
	// Timer/Counter0 CTC 8x prescaler
	TCCR0A = 2<<WGM00;
	TCCR0B = 1<<CS01;
	// Reset prescaler
	GTCCR |= 1<<PSR0;
	// Reset counter0
	TCNT0 = 0;

	// Number of bits to count
	OCR0A = 48;

	// Clear output compare interrupt flag
  TIFR |= 1 << OCF0A;
	// Enable output compare interrupt
	TIMSK |= 1<<OCIE0A;

	sei();
}

ISR (PCINT0_vect) {
  if (!(PINB & 1<<PINB0)) {
		startUARTReceive();
  }
}

uint8_t ReverseByte (uint8_t x) {
    x = ((x >> 1) & 0x55) | ((x << 1) & 0xaa);
    x = ((x >> 2) & 0x33) | ((x << 2) & 0xcc);
    x = ((x >> 4) & 0x0f) | ((x << 4) & 0xf0);
    return x;
}

ISR (TIMER0_COMPA_vect) {
	// Disable COMPA interrupt
	TIMSK &= ~(1<<OCIE0A);
	// Reset counter0
	TCNT0 = 0;
	// Shift every bit width this time
  OCR0A = 104;

	// Configure USI to use Timer/Counter0's CTC as clock source
	// , disable any wiremode and enable overflow interrupt
	USICR |=
		1<<USICS0 |
		0<<USIWM1 | 0<<USIWM0|
		1<<USIOIE;
	// Clear the overflow flag and start counting at 8,
	// so only 8 bit are being read instead of 16
	USISR = 1<<USIOIF | 8;
}

void clearUARTBuffer() {
	uartBufferIndex = 0;
	uartBuffer[0] = '\0';
}

ISR (USI_OVF_vect) {
	cli();
  usiByteReceived = USIBR;
	if (uartBufferIndex >= UART_BUFFER_SIZE-1) {
		uartBuffer[0] = USIBR;
		uartBuffer[1] = '\0';
		uartBufferIndex = 1;
	} else {
		uartBuffer[uartBufferIndex] = USIBR;
		uartBuffer[uartBufferIndex+1] = '\0';
		uartBufferIndex++;
	}
  USICR = 0;
	usiReceived = 1;

	// Restore old timer values
	TCCR0A = oldTCCR0A;
	TCCR0B = oldTCCR0B;
	// Note Arduino millis() and micros() will loose the time it took us to receive a byte
	// Approximately 1ms at 9600 baud
	TCNT0 = oldTCNT0;

	// Clear pin change interrupt flag
	GIFR = 1<<PCIF;
	// Enable pin change interrupts again
  GIMSK |= 1<<PCIE;
	sei();
}

ISR (TIMER1_COMPA_vect) {
	// Disable COMPA interrupt
	/* TIMSK &= ~(1<<OCIE1A); */
	if (timer1Mode == SQUARE) {
		if (timer1SquareLevel) {
			PORTB |= 1<<PB4;
		} else {
			PORTB &= ~(1<<PB4);
		}
		timer1SquareLevel = 1-timer1SquareLevel;
	} else if (timer1Mode == COUNT) {
		timer1CounterMs++;
	}
}

void sleep_delay_ms(unsigned long ms) {
	cli();
	timer1Mode = COUNT;
	timer1CounterMs = 0;
	// Timer/Counter1 CTC with prescaler 64, use OCR1C
	TCCR1 = 
		1<<CTC1 | 7<<CS10;
	// Reset prescaler
	GTCCR |= 1<<PSR1;
	// Reset counter0
	TCNT1 = 0;

	// To pulse every milliseconds
	OCR1C = 125;

	// Clear output compare interrupt flag
  TIFR |= 1 << OCF1A;
	// Enable output compare interrupt
	TIMSK |= 1<<OCIE1A;
	sei();

	for(;;) {
		if (timer1CounterMs >= ms) {
			// Disable Timer/Counter1
			TIMSK &= ~(1<<OCIE1A);
			return;
		}
	}
}

void set_square(uint8_t us) {
	cli();
	timer1Mode = SQUARE;
	timer1SquareLevel = 1;
	// Timer/Counter1 CTC with prescaler 8, use OCR1C
	TCCR1 = 
		1<<CTC1 | 4<<CS10;
	// Reset prescaler
	GTCCR |= 1<<PSR1;
	// Reset counter0
	TCNT1 = 0;

	OCR1C = us;

	// Clear output compare interrupt flag
  TIFR |= 1 << OCF1A;
	// Enable output compare interrupt
	TIMSK |= 1<<OCIE1A;
	sei();
}
void blink(uint8_t n, int delay) {
	for (uint8_t i = 0; i < n; ++i) {
		PORTB |= (1<<PB4);
		sleep_delay_ms(delay);
		PORTB &= ~(1<<PB4);
		sleep_delay_ms(delay);
	}
}

void wait_click() {
	while (PINB & 1<<PB1);
	while (!(PINB & 1<<PB1));
}

void debugSquareBuffer() {
	wait_click();
	int s = uartBufferIndex;
	if (s > 0) {
		for (int i = 0; i < s; ++i) {
			set_square(ReverseByte(uartBuffer[i]));
			wait_click();
		}
	}
	blink(2, 200);
}

void setup_watchdog(int ii) {
  uint8_t bb;
  if (ii > 9 ) ii=9;
  bb=ii & 7;
  if (ii > 7) bb|= (1<<5);
  bb|= (1<<WDCE);
  MCUSR &= ~(1<<WDRF);
  // start timed sequence
  WDTCR |= (1<<WDCE) | (1<<WDE);
  // set new watchdog timeout value
  WDTCR = bb;
  WDTCR |= 1<<WDIE;
}

void wdt_sleep() {
	uint8_t oldMCUCR = MCUCR;
	uint8_t oldDDRB = DDRB;
	/* DDRB = 0; */
	ADCSRA &= ~(1<<ADEN);
	/* PRR |= 15; */
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);

	MCUCR |=
		1<<SM1 |
		1<<BODS | 1<<BODSE;
	MCUCR &=
		~(1<<BODSE) &
		~(1<<SM0);
	
	sleep_mode();

	ADCSRA |= 1<<ADEN;
	/* PRR &= ~(15); */
	MCUCR = oldMCUCR;
	DDRB = oldDDRB;
}
// Mandatory
ISR(WDT_vect) {}

int main(void) {
	setupUART();
	setup_watchdog(8);
	// INPUT_PULLUP on DB1
	DDRB &= ~(1<<DDB1);
	PORTB |= 1 << PB1;
	// OUTPUT PB4 Low
	DDRB |= (1<<PB4);
	PORTB &= ~(1<<PB4);
	for (;;) {
		wdt_sleep();
		set_square(255);
		_delay_ms(500);
		TIMSK &= ~(1<<OCIE1A);
		PORTB &= ~(1<<PB4);
		_delay_ms(500);
		uint8_t expected_msg[] = {
			83, 65, 76, 85, 84, 69, 32, 78, 69, 65, 76
		};
		int expected_msg_size = sizeof(expected_msg);
		int bi = uartBufferIndex;
		if (bi >= expected_msg_size) {
			/* wait_click(); */
			int ok = 1;
			for (int i = 0; i < expected_msg_size; ++i) {
				if (ReverseByte(uartBuffer[i]) != expected_msg[i]) {
					ok = 0;
					break;
				}
			}
			if (ok) {
				blink(4, 200);
			} else {
				blink(2, 200);
			}
			clearUARTBuffer();
		} else {
			blink(bi, 200);
			clearUARTBuffer();
		}
	}

	return 0;
}
